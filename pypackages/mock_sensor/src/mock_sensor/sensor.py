"""A mock sensor for testing."""

import json
import logging
import random
from time import time
from typing import Iterator

import influxdb_client_3 as influx
import paho.mqtt.client as mqtt
from influxdb_client_3 import WritePrecision

from .config import AuthSettings, MetricConfig, SensorConfig


def random_walk(x0: float, max_step: float, min_x: float, max_x: float) -> Iterator[float]:
    """Generate a random walk starting from x0.

    Each step is a random value in the range [-max_step, max_step].
    The value is clamped to the range [min_x, max_x].

    Args:
        x0 (float): Starting value.
        max_step (float): Maximum step size.
        min_x (float): Minimum value.
        max_x (float): Maximum value.

    Yields:
        float: The next value in the random walk.
    """
    x = x0
    while True:
        step = random.uniform(-max_step, max_step)
        x = max(min_x, min(max_x, x + step))
        yield x


class Metric:
    """A metric generated by our mock sensor."""

    def __init__(self, config: MetricConfig):
        self.config = config
        """The configuration settings of the metric."""

        self._generator = random_walk(
            config.initial_value,
            config.max_step,
            config.min_value,
            config.max_value,
        )
        """A generator that produces the metric values."""

    def __call__(self) -> float:
        """Get the next value of the metric."""
        return next(self._generator)


class MockSensor:
    """A mock sensor that generates random metrics.

    The sensor can publish metrics to an MQTT broker and/or write them to an InfluxDB database.
    """

    def __init__(
        self,
        config: SensorConfig,
        auth_settings: AuthSettings,
    ):
        self.name = config.name
        """A short name for the sensor.

        For MQTT, this is appended to the topic prefix (default "sensors/mock") to form the
        full topic.  For InfluxDB, this is appended to the measurement prefix (default
        "mock_sensor") to form the full measurement name.

        Example: foo -> `sensors/mock/foo` (MQTT) and `mock_sensor_foo` (InfluxDB)
        """

        self.description = config.description
        """A longer description of the sensor."""

        self.metric_configs = config.metrics
        """The list of metrics generated by the sensor."""

        self.mqtt_config = config.mqtt_config
        """An optional MQTT client to publish metrics to."""

        self.influx_config = config.influx_config
        """An optional InfluxDB client to write metrics to."""

        self.interval = config.interval
        """The interval (in seconds) between metric generations."""

        self.mqtt_client = None
        self.influx_client = None

        if self.influx_config:
            assert auth_settings.influx_token, "InfluxDB token is required"

        self.mqtt_topic: str | None = None
        self.influx_measurement_name: str | None = None
        self.metrics = [Metric(cfg) for cfg in self.metric_configs]

        if self.mqtt_config:
            self.mqtt_topic = f"{self.mqtt_config.topic_prefix}/{self.name}"

            # Set up MQTT client
            self.mqtt_client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
            if auth_settings.mqtt_username and auth_settings.mqtt_password:
                self.mqtt_client.username_pw_set(
                    auth_settings.mqtt_username, auth_settings.mqtt_password
                )

        if self.influx_config:
            self.influx_measurement_name = f"{self.influx_config.measurement_prefix}_{self.name}"

            # Set up InfluxDB client
            self.influx_client = influx.InfluxDBClient3(
                host=self.influx_config.url,
                token=auth_settings.influx_token,
                database=self.influx_config.database,
            )

    def run(self):
        """Run the mock sensor, publishing metrics to MQTT and/or InfluxDB."""
        self.mqtt_client.connect(self.mqtt_config.hostname, self.mqtt_config.port)
        self.mqtt_client.loop_start()

        try:
            while True:
                timestamp = int(time() * 1_000_000_000)  # timestamp in nanoseconds

                # Generate metric values
                values = {"timestamp": timestamp} | {
                    metric.name: metric() for metric in self.metrics
                }

                json_payload = json.dumps(values)

                # Regardless of output method(s), log the generated values
                logging.info("%s", json_payload)

                if self.mqtt_client:
                    # Publish to MQTT
                    self.mqtt_client.publish(self.mqtt_topic, json_payload)

                if self.influx_client:
                    # Write to InfluxDB
                    point = influx.Point(self.influx_measurement_name)
                    for key, value in values.items():
                        if key == "timestamp":
                            continue
                        point = point.field(key, value)
                    point = point.time(timestamp, write_precision=WritePrecision.NS)
                    self.influx_client.write(record=point, precision=WritePrecision.NS)
                time.sleep(self.interval)
        except KeyboardInterrupt:
            if self.mqtt_config:
                self.mqtt_client.loop_stop()
                self.mqtt_client.disconnect()
