"""A mock sensor for testing."""

import logging
import random
from time import sleep, time_ns
from typing import Iterator

import paho.mqtt.client as mqtt

from .config import AuthSettings, MetricConfig, SensorConfig


def random_walk(x0: float, max_step: float, min_x: float, max_x: float) -> Iterator[float]:
    """Generate a random walk starting from x0.

    Each step is a random value in the range [-max_step, max_step].
    The value is clamped to the range [min_x, max_x].

    Args:
        x0 (float): Starting value.
        max_step (float): Maximum step size.
        min_x (float): Minimum value.
        max_x (float): Maximum value.

    Yields:
        float: The next value in the random walk.
    """
    x = x0
    while True:
        step = random.uniform(-max_step, max_step)
        x = max(min_x, min(max_x, x + step))
        yield x


class Metric:
    """A metric generated by our mock sensor."""

    def __init__(self, config: MetricConfig):
        self.config = config
        """The configuration settings of the metric."""

        self._generator = random_walk(
            config.initial_value,
            config.max_step,
            config.min_value,
            config.max_value,
        )
        """A generator that produces the metric values."""

    def __call__(self) -> float:
        """Get the next value of the metric."""
        return next(self._generator)


class MockSensor:
    """A mock sensor that generates random metrics.

    The sensor can publish metrics to an MQTT broker and/or write them to an InfluxDB database.
    """

    def __init__(
        self,
        config: SensorConfig,
        auth_settings: AuthSettings,
    ):
        self.name = config.name
        """A short name for the sensor.

        For MQTT, this is appended to the topic prefix (default "sensors/mock") to form the
        full topic.  For InfluxDB, this is appended to the measurement prefix (default
        "mock_sensor") to form the full measurement name.

        Example: foo -> `sensors/mock/foo` (MQTT) and `mock_sensor_foo` (InfluxDB)
        """

        self.description = config.description
        """A longer description of the sensor."""

        self.metric_configs = config.metrics
        """The list of metrics generated by the sensor."""

        self.mqtt_config = config.mqtt_config
        """An optional MQTT client to publish metrics to."""

        self.interval = config.interval
        """The interval (in seconds) between metric generations."""

        self.mqtt_client = None
        self.mqtt_topic: str | None = None
        self.metrics = [Metric(cfg) for cfg in self.metric_configs]

        if self.mqtt_config:
            self.mqtt_topic = f"{self.mqtt_config.topic_prefix}/{self.name}"

            logging.info(
                "Publishing to MQTT broker %s:%d, topic %s",
                self.mqtt_config.hostname,
                self.mqtt_config.port,
                self.mqtt_topic,
            )

            # Set up MQTT client
            self.mqtt_client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
            if auth_settings.mqtt_username and auth_settings.mqtt_password:
                self.mqtt_client.username_pw_set(
                    auth_settings.mqtt_username, auth_settings.mqtt_password
                )
        else:
            logging.info("Publishing to MQTT broker disabled.")
        logging.info("")
        logging.info("")

    def run(self):
        """Run the mock sensor, publishing metrics to MQTT and/or InfluxDB."""
        if self.mqtt_client:
            self.mqtt_client.connect(self.mqtt_config.hostname, self.mqtt_config.port)
            self.mqtt_client.loop_start()

        try:
            while True:
                ts, ts_ns = divmod(time_ns(), 1_000_000_000)
                payload = f"ts {ts} ts_ns {ts_ns} "  # Timestamp in seconds with nanoseconds

                # For our mock sensor, we assume 2 decimal places of precision for all metrics
                values = {metric.config.name: metric() for metric in self.metrics}
                payload += " ".join(f"{k} {v:.2f}" for k, v in values.items())

                # Regardless of output method(s), log the generated values
                logging.info("%s", payload)

                if self.mqtt_client:
                    # Publish to MQTT
                    self.mqtt_client.publish(self.mqtt_topic, payload)

                sleep(self.interval)
        except KeyboardInterrupt:
            if self.mqtt_config:
                self.mqtt_client.loop_stop()
                self.mqtt_client.disconnect()
