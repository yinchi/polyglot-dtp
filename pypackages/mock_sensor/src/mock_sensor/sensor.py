"""A mock sensor for testing."""

import hmac
import logging
import random
import re
from binascii import b2a_base64
from time import sleep, time_ns
from typing import Iterator

import paho.mqtt.client as mqtt

from .config import AuthSettings, MetricConfig, SensorConfig


def random_walk(x0: float, max_step: float, min_x: float, max_x: float) -> Iterator[float]:
    """Generate a random walk starting from x0.

    Each step is a random value in the range [-max_step, max_step].
    The value is clamped to the range [min_x, max_x].

    Args:
        x0 (float): Starting value.
        max_step (float): Maximum step size.
        min_x (float): Minimum value.
        max_x (float): Maximum value.

    Yields:
        float: The next value in the random walk.
    """
    x = x0
    while True:
        step = random.uniform(-max_step, max_step)
        x = max(min_x, min(max_x, x + step))
        yield x


class Metric:
    """A metric generated by our mock sensor."""

    def __init__(self, config: MetricConfig):
        self.config = config
        """The configuration settings of the metric."""

        self._generator = random_walk(
            config.initial_value,
            config.max_step,
            config.min_value,
            config.max_value,
        )
        """A generator that produces the metric values."""

    def __call__(self) -> float:
        """Get the next value of the metric."""
        return next(self._generator)


class MockSensor:
    """A mock sensor that generates random metrics and publishes them to MQTT (optional)."""

    def __init__(
        self,
        config: SensorConfig,
        auth_settings: AuthSettings,
    ):
        self.name = config.name
        """A short name for the sensor."""

        self.description = config.description
        """A longer description of the sensor."""

        self.metric_configs = config.metrics
        """The list of metrics generated by the sensor."""

        self.interval = config.interval
        """The interval (in seconds) between metric generations."""

        self.mqtt_client: mqtt.Client | None = None
        """The MQTT client used to publish metrics.  None if MQTT is disabled."""

        self.mqtt_topic = config.mqtt_topic
        """The MQTT topic to publish metrics to.  None if MQTT is disabled."""

        self.hmac_key: bytes | None = None
        """An HMAC key used to sign MQTT messages.  None if MQTT is disabled."""

        self.metrics = [Metric(cfg) for cfg in self.metric_configs]
        """The list of Metric objects generated by the sensor."""

        self.auth_settings = auth_settings
        """The authentication settings for MQTT."""

        if auth_settings.mqtt_hostname:
            assert auth_settings.mqtt_hmac_key.get_secret_value(), "HMAC key cannot be empty"
            assert self.mqtt_topic, "MQTT topic cannot be empty"
            assert re.fullmatch(r"\w+(?:/\w+)*", self.mqtt_topic), "Invalid MQTT topic"

            self.hmac_key = auth_settings.mqtt_hmac_key.get_secret_value().encode("utf-8")

            logging.info(
                "Publishing to MQTT broker %s:%d, topic %s",
                auth_settings.mqtt_hostname,
                auth_settings.mqtt_port or 1883,
                self.mqtt_topic,
            )

            # Set up MQTT client
            self.mqtt_client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
            if auth_settings.mqtt_username and auth_settings.mqtt_password:
                self.mqtt_client.username_pw_set(
                    auth_settings.mqtt_username, auth_settings.mqtt_password
                )
        else:
            logging.info("Publishing to MQTT broker disabled.")
        logging.info("")
        logging.info("")

    def run(self):
        """Run the mock sensor, publishing metrics to MQTT and/or InfluxDB."""
        if self.mqtt_client:
            self.mqtt_client.connect(self.auth_settings.mqtt_hostname, self.auth_settings.mqtt_port)
            self.mqtt_client.loop_start()

        try:
            while True:
                ts, ts_ns = divmod(time_ns(), 1_000_000_000)
                payload = f"ts {ts} ts_ns {ts_ns} "  # Timestamp in seconds with nanoseconds

                # For our mock sensor, we assume 2 decimal places of precision for all metrics
                values = {metric.config.name: metric() for metric in self.metrics}
                payload += " ".join(f"{k} {v:.2f}" for k, v in values.items())

                digest = b2a_base64(
                    hmac.digest(self.hmac_key, payload.encode("utf-8"), "sha256"),
                    newline=False,
                ).decode("utf-8")
                msg = f"{digest} {payload}"

                # Regardless of output method(s), log the generated values
                logging.info("%s", msg)

                if self.mqtt_client:
                    # Publish to MQTT
                    self.mqtt_client.publish(self.mqtt_topic, msg)

                sleep(self.interval)
        except KeyboardInterrupt:
            if self.mqtt_client:
                self.mqtt_client.loop_stop()
                self.mqtt_client.disconnect()
