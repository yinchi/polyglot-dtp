"""A mock sensor for testing."""

import hmac
import json
import logging
import random
import re
import signal
import sys
from binascii import b2a_base64
from time import sleep, time_ns
from typing import Iterator

import paho.mqtt.client as mqtt

from .config import AuthSettings, MetricConfig, SensorConfig

# Canonical JSON encoding settings: no whitespace, sorted keys
# Used to ensure 1-to-1 mapping between objects and their JSON string representation
# (for HMAC signing and verification)
CANONICAL_JSON = {
    "indent": None,
    "separators": (",", ":"),
    "sort_keys": True,
}

# Ensure we exit cleanly on SIGTERM (e.g. from `docker stop`)
signal.signal(signal.SIGTERM, lambda _signum, _frame: sys.exit(0))


def random_walk(x0: float, max_step: float, min_x: float, max_x: float) -> Iterator[float]:
    """Generate a random walk starting from x0.

    Each step is a random value in the range [-max_step, max_step].
    The value is clamped to the range [min_x, max_x].

    Args:
        x0 (float): Starting value.
        max_step (float): Maximum step size.
        min_x (float): Minimum value.
        max_x (float): Maximum value.

    Yields:
        float: The next value in the random walk.
    """
    x = x0
    while True:
        step = random.uniform(-max_step, max_step)
        x = max(min_x, min(max_x, x + step))
        yield x


class Metric:
    """A metric generated by our mock sensor."""

    def __init__(self, config: MetricConfig):
        self.config = config
        """The configuration settings of the metric."""

        self._generator = random_walk(
            config.initial_value,
            config.max_step,
            config.min_value,
            config.max_value,
        )
        """A generator that produces the metric values."""

    def __call__(self) -> float:
        """Get the next value of the metric."""
        return next(self._generator)


class MockSensor:
    """A mock sensor that generates random metrics and publishes them to MQTT (optional)."""

    def __init__(
        self,
        config: SensorConfig,
        auth_settings: AuthSettings,
    ):
        self.name = config.name
        """A short name for the sensor."""

        self.description = config.description
        """A longer description of the sensor."""

        self.metric_configs = config.metrics
        """The list of metrics generated by the sensor."""

        self.interval = config.interval
        """The interval (in seconds) between metric generations."""

        self.mqtt_client: mqtt.Client | None = None
        """The MQTT client used to publish metrics.  None if MQTT is disabled."""

        self.mqtt_topic = config.mqtt_topic
        """The MQTT topic to publish metrics to.  None if MQTT is disabled."""

        self.hmac_key: bytes | None = None
        """An HMAC key used to sign MQTT messages.  None if MQTT is disabled."""

        self.metrics = [Metric(cfg) for cfg in self.metric_configs]
        """The list of Metric objects generated by the sensor."""

        self.auth_settings = auth_settings
        """The authentication settings for MQTT."""

        if auth_settings.mqtt_hostname:
            assert auth_settings.mqtt_hmac_key.get_secret_value(), "HMAC key cannot be empty"
            assert self.mqtt_topic, "MQTT topic cannot be empty"
            assert re.fullmatch(r"[a-z0-9-]+(?:/[a-z0-9-]+)*", self.mqtt_topic), (
                "Invalid MQTT topic: use only a-z, 0-9, hyphen, and / "
                "(no double, leading or trailing /)"
            )

            self.hmac_key = auth_settings.mqtt_hmac_key.get_secret_value().encode("utf-8")

            logging.info(
                "Publishing to MQTT broker %s:%d, topic %s",
                auth_settings.mqtt_hostname,
                auth_settings.mqtt_port or 1883,
                self.mqtt_topic,
            )

            # Set up MQTT client
            self.mqtt_client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
            if auth_settings.mqtt_username and auth_settings.mqtt_password:
                self.mqtt_client.username_pw_set(
                    auth_settings.mqtt_username, auth_settings.mqtt_password
                )
        else:
            logging.info("Publishing to MQTT broker disabled.")
        logging.info("")
        logging.info("")

    def run(self):
        """Run the mock sensor, publishing metrics to MQTT and/or InfluxDB."""
        if self.mqtt_client:
            ret_code = self.mqtt_client.connect(
                self.auth_settings.mqtt_hostname, self.auth_settings.mqtt_port
            )
            if ret_code != 0:
                logging.warning(f"Failed to connect to MQTT broker: {ret_code}")
                logging.warning("MQTT messages may be lost.")
            self.mqtt_client.loop_start()

        try:
            while True:
                ts, ts_ns = divmod(time_ns(), 1_000_000_000)

                payload = {"ts": ts, "ts_ns": ts_ns} | {
                    metric.config.name: round(metric(), metric.config.precision)
                    for metric in self.metrics
                }
                # JSON-encode using compact canonical form (no whitespace, sorted keys)
                # to ensure 1-to-1 mapping between payload and payload_str
                payload_str = json.dumps(payload, **CANONICAL_JSON)

                digest = b2a_base64(
                    hmac.digest(self.hmac_key, payload_str.encode("utf-8"), "sha256"),
                    newline=False,
                ).decode("utf-8")

                # Since we used a canonical JSON representation for the payload (1-to-1 mapping),
                # we can just embed the payload instead of payload_str
                msg = json.dumps({"payload": payload, "hmac": digest}, **CANONICAL_JSON)

                # Regardless of output method(s), log the generated values
                logging.info("%s", msg)

                if self.mqtt_client:
                    # Publish to MQTT
                    self.mqtt_client.publish(self.mqtt_topic, msg)

                sleep(self.interval)
        except KeyboardInterrupt:
            pass
        finally:
            if self.mqtt_client:
                logging.info("")
                logging.info("")
                logging.info("Disconnecting from MQTT broker...")
                self.mqtt_client.loop_stop()
                self.mqtt_client.disconnect()
                logging.info("Disconnected.")
